import readline from 'node:readline';
import MuteStream from 'mute-stream';
import ScreenManager from './lib/screen-manager.js';
import { getPromptConfig } from './lib/options.js';
export { usePrefix } from './lib/prefix.js';
export * from './lib/key.js';
export * from './lib/Paginator.js';
let sessionRl;
let hooks = [];
const hooksCleanup = [];
let index = 0;
let handleChange = () => { };
const cleanupHook = (index) => {
    const cleanFn = hooksCleanup[index];
    if (typeof cleanFn === 'function') {
        cleanFn();
    }
};
export function useState(defaultValue) {
    const _idx = index;
    index++;
    if (!(_idx in hooks)) {
        hooks[_idx] = defaultValue;
    }
    return [
        hooks[_idx],
        (newValue) => {
            hooks[_idx] = newValue;
            // Trigger re-render
            handleChange();
        },
    ];
}
export function useEffect(cb, depArray) {
    const _idx = index;
    index++;
    const oldDeps = hooks[_idx];
    let hasChanged = true;
    if (oldDeps) {
        hasChanged = depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
    }
    if (hasChanged) {
        cleanupHook(_idx);
        hooksCleanup[_idx] = cb();
    }
    hooks[_idx] = depArray;
}
export function useKeypress(userHandler) {
    const rl = sessionRl;
    if (!rl) {
        throw new Error('useKeypress must be used within a prompt');
    }
    useEffect(() => {
        const handler = (_input, event) => {
            userHandler(event, rl);
        };
        rl.input.on('keypress', handler);
        return () => {
            rl.input.removeListener('keypress', handler);
        };
    }, [userHandler]);
}
export function useRef(val) {
    return useState({ current: val })[0];
}
export function createPrompt(view) {
    const prompt = async (config, context) => {
        // Default `input` to stdin
        const input = context?.input ?? process.stdin;
        // Add mute capabilities to the output
        const output = new MuteStream();
        output.pipe(context?.output ?? process.stdout);
        const rl = readline.createInterface({
            terminal: true,
            input,
            output,
        });
        const screen = new ScreenManager(rl);
        // TODO: we should display a loader while we get the default options.
        const resolvedConfig = await getPromptConfig(config);
        return new Promise((resolve) => {
            const done = (value) => {
                let len = hooksCleanup.length;
                while (len--) {
                    cleanupHook(len);
                }
                if (context?.clearPromptOnDone) {
                    screen.clean();
                }
                else {
                    screen.clearContent();
                }
                screen.done();
                // Reset hooks state
                hooks = [];
                index = 0;
                sessionRl = undefined;
                // Finally we resolve our promise
                resolve(value);
            };
            index = 0;
            hooks = [];
            const workLoop = () => {
                sessionRl = rl;
                index = 0;
                handleChange = () => workLoop();
                const nextView = view(resolvedConfig, done);
                const [content, bottomContent] = typeof nextView === 'string' ? [nextView] : nextView;
                screen.render(content, bottomContent);
            };
            workLoop();
        });
    };
    return prompt;
}
